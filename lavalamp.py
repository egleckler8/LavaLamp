from PIL import Image
import numpy as np, noise
from random import random, randint

# The image is a square, so this is the size of each side in pixels. Feel free to change!
# Bigger is cooler, but remember that it might take a LOT longer to process... I still need to work on optimizing this program

def randParams():
     
     '''  Generates a list of random parameters
          
          p[0] = scale -  How "zoomed in" the noise is. RANGE = (10.0, 210.0), MU ≅ 110.0

          p[1] = octaves - how many overtones are added to smooth the noise. RANGE = (1, 11), MU ≅ 6.00

          p[2] = persistence - the relative amplitude of each next octave. RANGE = (0, 0.95), MU ≅ 0.475

          p[3] = lacunarity - the relative frequency of each next octave. RANGE = (1.0, 4.0), MU ≅  2.50

          p[4] = z value - just a randomization factor... basically where it starts in the 3D field. RANGE = (0.0, 1.0), MU ≅ 0.50

          p[5] = strength - how powerful the noise field is. RANGE = (0.0, 1.0), MU ≅ 0.50 '''
     
     scale = round(10 + 200 * random(), 4)
     octaves = round(randint(1, 11), 4)
     persistence = round(random(), 4)
     lacunarity = 1 + 3 * round(random(), 4)
     z = round(random(), 4)
     strength=round(random(), 4)


     #scale = 110 # for testing purposes
     #octaves = 6 # for testing purposes
     #persistence = 0.5 # for testing purposes
     #lacunarity = 2.50 # for testing purposes
     #z = 0.5 # for testing purposes
     #strength = 0.5 # for testing purposes


     return [scale, octaves, persistence, lacunarity, z, strength]


class LampGen():
     '''  This class contains all the code necessary to generate a trippy, swirly animation.
          Default size is 256x256, default frames is 50.    '''

     # DEFAULTS
     def __init__(self, size=256, frames=50):
          self.img_size = size
          self.total_frames = frames


     def createSample(self, p) :
          '''  Creates a random 3D perlin noise field.
               p is the list of parameters, presumably generated by the seed or user. '''

          scale = p[0]  # Adjust this value to control the "zoom" of the noise
          octaves = p[1]   # Number of layers of noise to combine
          persistence = p[2]  # Controls the increase in amplitude with each octave
          lacunarity = p[3]   # Controls the increase in frequency with each octave
          z = p[4] # we use a 2D "slice" of a 3d noise field at a random z-coordinate so each field isn't the same each time--the noise module is determinate
          weight = p[5] # this is how strong the noise layer will come through in the final image as a percentage

          # EXPLANATION OF THIS PART OF THE PROGRAM

          # Notice the sample is initialized as a 2D array
          # We'll end up creating a sample for every frame of the animation, and each frame is obviously 2D
          # The sample array represents the R, G, and B values (3 sets of 3D noise fields for the image)
          # We'll initialize the array to zeros, then use nested for loops to set each point in the array 
          # to the value of a pnoise3 sample at the corresponding x, y, z (while z is fixed, x and y vary)

          # Why don't use the z value? That's because the z value only changes between each frame of the animation.
          # This shifting z value gives us the swirly effect. Imagine cutting a cube of swiss chese into a bunch of little slices...
          # Each "frame" of our animation is one of those slices. The transition between each slice is smooth, since Perlin noise is smooth
          # Exactly like cheese! Our "motion" is just tracing the "holes" of the swiss cheese, if that makes sense.
          # So, the loop that later makes each frame will sumbit a differet parameter list p to this function
          # Each iteration of the loop will submit a slightly different p, the only difference being a slighlty incremented p
          # Well, we might play around with other paramters too... but that's for later notes... ;) 
          # The z-increment is the "width" of our slice, think "dz" from calculus

          # We'll end up making "total_frames" frames (50 is default) for each R, G, and B.
          # This means we'll call this function 3 * total_frames times. 
          # Calling the pnoise() function so many times could be expensive, depending on the parameters
          # e.g. higher octaves value usually takes longer to process

          # Again, this is the chunk of the program that is the most expensive.
          # We're iterating over every pixel in every frame 3 times (R, G, and B)!!
          # So, the total time it takes to create every frame heavily depends on image size and total frames.
          # Increasing image size by a factor of 2 (e.g. 200x200 --> 400x400) increases the runtime of this part by at least 4x! (exlcuding other factors)

          # Anyways... here we go with the initialization of the zeroes array
          sample = np.zeros((self.img_size, self.img_size))

          # Next we'll set each index of the array to a noise value
          for x in range(self.img_size):
               for y in range(self.img_size):
                    noise_value = noise.pnoise3(  x / scale,
                                                  y / scale, 
                                                  z,
                                                  octaves=octaves,
                                                  persistence=persistence,
                                                  lacunarity=lacunarity   )
                    
                    # This little calculation determines how much this noise layer will shine though
                    # Since each noise layer corresponds to the R, G, or B of each pixel, this is how one could change the "mood" of their LampGen
                    # Yeah the weight basically changes the color of the whole thing
                    # Everything is multiplied by 256 to make the sample's noise fit into RGB
                    # INTERESTING FACT: Pillow wraps negative RBG values around; and RGB of -10 will be read as 255 - 10 = 245 basically, so no need to abs() the noise_value
                    sample[x][y] = 256 * weight * noise_value

          return sample


     def createSwirl(self, amplitude=1.0):
          '''  Returns a list of smooth noise values to create swirls. 
               We'll use this function to control the paramter swirls, like if we want the scale to change
               frame by frame, or lacunarity, etc. This gives us a smooth, random change so each GIF stays completely unique.
               We could've used math.sin() or something to give a smooth wave, but the fun here is that it's random 
          
               Amplitude controls... well, yeah... Amplitude defaults at 1, which means the step values will range 0-1 '''
          
          swirl_noise = np.zeros((self.total_frames))

          for x in range(self.total_frames):
               noise_value = noise.pnoise1(x - 0.888, octaves=6) # this 0.888 is SUPER IMPORTANT because perlin noise always is 0 at int values!!
               swirl_noise[x] = amplitude * noise_value

          return swirl_noise
     

     def createGIF(self, filepath="", 
                   R_strength=0.5, 
                   B_strength=0.5, 
                   G_strength=0.5, ):
          '''  Creates trippy gif and saves it. 
               By default, the gif is generated using a random seed and saved to the working directory
               Also by default, the randParams method is called 3 times to generate a "seed." Eventually, I hope to write
               a function to be called below that converts any input seed into a list of 3 parameters
               Additionally, I'd love to find a way to make the seed super compact but retain unfathomable randomness
           
               This is the primary method that will be called by users of the LampGen class.
               It's the only one we need to ever look at outside of this class!!! Yay!
               Makes it easy for anyone to call the method and make their own generative art.
               '''
          
          # Right here is where some future "seed converter" method would go instead of params = seed
          # I'd write seed = convertSeed(s) and it'd gurantee the seed works
          # no matter what the user inputs.
          # IT MUST have the output of a list of three parameter lists (one for each R, G, B)
          # So that the line below that makes the params list can turn the seed into params
          # Currently, s is a 3 term list anyway so... this seems redundant
          # But eventually I'll want s to be a 10-digit number or something
          # Then the future method that will be here will 
          # 1. take seed 
          # 2. and turn it into the 3 term list (def new method?)
          # 3. store it in params          

          # Uhhhh yeah... This is the inelegant method I've come up with so that we can have
          # Default parameters be random, and then kinda override it a little if we want
          # Since I stared developing the GUI with only (R, G, B)_strength, I thought this would be
          # a good start to figuring out this problem while I test the GUI

          seed = [randParams(), randParams(), randParams()]
          seed[0][5] = R_strength
          seed[1][5] = G_strength
          seed[2][5] = B_strength

          # Using the seeds, generate the paramters for each color noise layer
          # Basically, the first term in the seed list goes to Red
          # Second goes to Blue, third to Green
          # And from those seeds we generate the params for the noise field for each color. Phew!
          params = seed

          # Create a new blank image with a specified size and color mode
          image = Image.new("RGB", (self.img_size, self.img_size), "black")

          # Turn the image into a 3D NumPy array
          # The array is in the form (width, height, RGB)
          # That is, the first two dimensions are width and height with length img_size
          # The value at each (width, height) is set by the noise sample we'll create
          map = np.array(image)

          # just for references in terminal
          #print("Seed: " + str(seed))
          #print("Parameters: " + str(params))

          # This is where the image files for each frame will be opened and stored to as they are generated
          frame_files = []

          # Send user a message to let them know what's up
          print("Generating gif...")

          # Create the files for each frame using our createSample() funciton
          # and add each trippy, colorful frame to a list of all the files
          for i in range(self.total_frames):

               # Each of these three 2D pnoise samples will correspond to the R, G, or B (order respective) or each pixel in the image
               # These three lines should take the runtime of 3 * total_frames * ((img_size**2) * noise complexity)
               # Where "noise complexity" is the time it takes to access one sample of the noise module's pnoise3
               # With the paramters given as list p. This can vary based on the value of some parameters.
               sampleRed = self.createSample(params[0]) 
               sampleGreen = self.createSample(params[1])
               sampleBlue = self.createSample(params[2])

               # This loop sets the color every pixel in the image (now a 3D np array, the 3rd D is the 3-term RGB array)
               # This is the part that actually binds each pixel of the image pixelmap to an RGB value!
               for x in range(self.img_size):
                    for y in range(self.img_size):
                         # map[x][y] sets the z dimension of the map
                         # The z dimension, according the the PIL libary, is to be 3 term lists of (R, G, B) values
                         # So here we finally colorize the image!!
                         map[x][y] = (sampleRed[x][y], sampleGreen[x][y], sampleBlue[x][y])

               # The following code turns the np array, fully colorized, to an image files and appends it to the frame_files array
               # Later, we'll turn frame_files into a gif!
               frame = Image.fromarray(map)
               frame_files.append(frame)

               # *** MODULATION STATION ***
               # To give the swirly motion, this code shifts the z value of each parameter array a little bit between each frame
               # Remember, we're still in a for loop!
               # Because the noise we're using for each of the RGB fields is actually a 2D slice (at a random pos.) of a fixed 3D noise field,
               # Incrementer the z parameter will slowly swipe through the 3D field and give the impression of smooth, swirly, smoke-like motion
               # Added color shifting (param[5]) too!
               # Think of slices of swiss cheese, like earlier.
               # Or, go back to the createSample() function to clarify. It's explained in detail there a little more.

               # COMMENTED OUR FOR NOW... THESE FEATURES MAY RETURN
               # NO SWILRING YET... WE'LL BE WORKING ON THIS
               # This creates the smooth noise pattern for the color swirl effect. 
               # Adjust amplitude so it is large enough to notiecably affect RGB
               #color_swirl = createSwirl()
               #scale_swirl = createSwirl(20)
               
               for param in params:
                    #param[0] += scale_swirl[i]
                    param[4] += 0.04

                    # This little conditional makes sure the RGB values don't go negative or over 255 and reverse, ruining the smoothness of the piece 
                    #step = color_swirl[i]
                    #if step < param[5] or param[5] + step > 255:
                    #param[5] += color_swirl[i]


          # Saves the array of frames as a gif!
          # My reasoning for the arguably obnoxious filename:
          # When custom seeding is implemented, I want each image to be recreateable if possible
          # I didn't want to have to go into the file notes, etc. and edit because I want this
          # program to be compatible on all operating systems with python3
          filename = f"IMG[{seed[0]}, {seed[1]}, {seed[2]}].gif"
          fp = filepath + '/' +  filename
          print(fp)

          try:
               # Thanks to ChatGPT for teaching me how to use Pillow to save a list of images as a gif
               frame_files[0].save(fp, save_all=True, append_images=frame_files[1:], duration=100, loop=0) # 0 means infinite loop
               print(f"******************************************************************************************************\n  Image successfully generated; it is now located at:\n  {fp}\n******************************************************************************************************")
          except Exception as e:
               print(f"******************************************************************************************************\n  ERROR: {e}\n  Image could not be generated.\n******************************************************************************************************")



